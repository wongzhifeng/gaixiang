// 街巷社区互助平台数据库设计
// 设计原则：简单易用、适合老年用户、支持智能匹配
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = "file:./dev.db"
}

// 用户表 - 社区居民信息
model User {
  id              String   @id @default(cuid())
  email           String   @unique
  name            String
  phone           String?  // 可选手机号
  avatar          String?  // 头像URL

  // 认证信息
  passwordHash    String?  // 密码哈希（可选，支持第三方登录）
  emailVerified   Boolean  @default(false) // 邮箱验证状态

  // 位置信息（模糊位置，保护隐私）
  locationLat     Float?   // 纬度
  locationLng     Float?   // 经度
  locationText    String?  // 位置描述（如：XX小区XX栋）

  // 用户状态
  onlineStatus    Boolean  @default(false)  // 在线状态
  isVerified      Boolean  @default(false)  // 是否验证
  trustLevel      Int      @default(0)      // 信任等级

  // 技能标签
  skills          String?  // JSON格式：'["技能1", "技能2"]'
  interests       String?  // JSON格式：'["兴趣1", "兴趣2"]'

  // 统计信息
  helpCount       Int      @default(0)      // 帮助次数
  receiveCount    Int      @default(0)      // 接受帮助次数

  // 时间戳
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  // 关系
  demands         Demand[]  // 发布的需求
  services        Service[] // 提供的服务
  sentMessages    Message[] @relation("SentMessages")
  receivedMessages Message[] @relation("ReceivedMessages")
  conversations   ConversationParticipant[]
  responses       Response[] // 对需求/服务的响应
  userAMatches    Match[] @relation("UserAMatches") // 作为用户A的匹配
  userBMatches    Match[] @relation("UserBMatches") // 作为用户B的匹配

  @@map("users")
}

// 需求表 - 用户发布的求助需求
model Demand {
  id          String   @id @default(cuid())
  title       String   // 需求标题
  description String   // 详细描述

  // 需求类型和状态
  type        String @default("GENERAL")  // 需求类型：GENERAL, EMERGENCY, REPAIR, CARE, SHOPPING, MOVING, LEARNING
  status      String @default("ACTIVE")    // 需求状态：ACTIVE, PENDING, COMPLETED, CANCELLED
  urgency     Int        @default(3)        // 紧急程度 1-5

  // 位置信息
  locationLat Float?    // 需求发生地纬度
  locationLng Float?    // 需求发生地经度
  locationText String?  // 需求发生地描述

  // 标签分类
  tags        String?   // JSON格式：'["标签1", "标签2"]'
  category    String    // 需求分类

  // 时间信息
  deadline    DateTime? // 截止时间
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  // 关系
  userId      String
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  responses   Response[] // 对该需求的响应
  matches     Match[]    // 匹配记录

  @@map("demands")
}

// 服务表 - 用户提供的服务
model Service {
  id          String   @id @default(cuid())
  title       String   // 服务标题
  description String   // 服务描述

  // 服务类型和状态
  type        String @default("GENERAL")   // 服务类型：GENERAL, REPAIR, CARE, SHOPPING, MOVING, TEACHING
  status      String @default("ACTIVE")    // 服务状态：ACTIVE, PAUSED, COMPLETED

  // 位置信息
  locationLat Float?    // 服务提供地纬度
  locationLng Float?    // 服务提供地经度
  locationText String?  // 服务提供地描述

  // 标签分类
  tags        String?   // JSON格式：'["标签1", "标签2"]'
  category    String    // 服务分类

  // 时间信息
  availableFrom DateTime? // 可提供服务开始时间
  availableTo   DateTime? // 可提供服务结束时间
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  // 关系
  userId      String
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  responses   Response[] // 对该服务的响应
  matches     Match[]    // 匹配记录

  @@map("services")
}

// 响应表 - 用户对需求/服务的响应
model Response {
  id          String   @id @default(cuid())

  // 响应类型
  type        String @default("DEMAND_RESPONSE") // 响应类型：DEMAND_RESPONSE, SERVICE_RESPONSE
  status      String @default("PENDING")         // 响应状态：PENDING, ACCEPTED, REJECTED, COMPLETED

  // 响应内容
  message     String?  // 响应消息

  // 时间信息
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // 关系
  userId      String
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  // 多态关联 - 可以响应需求或服务
  demandId    String?
  demand      Demand?  @relation(fields: [demandId], references: [id])
  serviceId   String?
  service     Service? @relation(fields: [serviceId], references: [id])

  @@map("responses")
}

// 匹配表 - 智能匹配记录
model Match {
  id          String   @id @default(cuid())

  // 匹配信息
  score       Float    // 匹配分数 0-100
  reason      String?  // 匹配原因

  // 匹配类型
  type        String @default("DEMAND_SERVICE") // 匹配类型：DEMAND_SERVICE, USER_USER

  // 时间信息
  createdAt   DateTime @default(now())

  // 关系
  demandId    String?
  demand      Demand?  @relation(fields: [demandId], references: [id])
  serviceId   String?
  service     Service? @relation(fields: [serviceId], references: [id])

  // 匹配的用户对
  userAId     String
  userA       User     @relation("UserAMatches", fields: [userAId], references: [id])
  userBId     String
  userB       User     @relation("UserBMatches", fields: [userBId], references: [id])

  @@map("matches")
}

// 对话表
model Conversation {
  id          String   @id @default(cuid())

  // 对话信息
  title       String?  // 对话标题
  lastMessage String?  // 最后一条消息

  // 信任机制
  trustProgress Int    @default(0) // 信任进度 0-100
  messageCount  Int    @default(0) // 消息数量

  // 时间信息
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // 关系
  participants ConversationParticipant[]
  messages     Message[]

  @@map("conversations")
}

// 对话参与者表
model ConversationParticipant {
  id             String       @id @default(cuid())

  // 关系
  userId         String
  user           User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  conversationId String
  conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)

  // 参与者状态
  isActive       Boolean      @default(true)
  joinedAt       DateTime     @default(now())

  @@unique([userId, conversationId])
  @@map("conversation_participants")
}

// 消息表
model Message {
  id          String   @id @default(cuid())

  // 消息内容
  content     String   // 消息内容
  type        String @default("TEXT") // 消息类型：TEXT, QUICK_REPLY, CONTACT

  // 时间信息
  createdAt   DateTime @default(now())

  // 关系
  senderId    String
  sender      User     @relation("SentMessages", fields: [senderId], references: [id], onDelete: Cascade)
  receiverId  String
  receiver    User     @relation("ReceivedMessages", fields: [receiverId], references: [id], onDelete: Cascade)
  conversationId String
  conversation Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)

  @@map("messages")
}